name: Draft Release

on:
  push:
    branches: 
      - 'release/**'
      - 'release/*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: docker.io
  IMAGE_NAME: karo

permissions:
  contents: write
  packages: read

jobs:
  prepare-release:
    name: Prepare Draft Release
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      prerelease: ${{ steps.version.outputs.prerelease }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: "1.24"
          cache: true

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger - use provided version
            VERSION="${{ inputs.version }}"
            if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
              echo "Invalid version format: $VERSION"
              echo "Expected format: vX.Y.Z, vX.Y.Z-prerelease, or vX.Y.Z+build"
              exit 1
            fi
            PRERELEASE="${{ inputs.prerelease }}"
          elif [[ "${{ github.ref_name }}" =~ ^release/ ]]; then
            # Release branch trigger - extract version from branch name
            BRANCH_NAME="${{ github.ref_name }}"
            echo "Release branch detected: $BRANCH_NAME"
            
            # Extract version from branch name (release/v1.0.0 or release/1.0.0)
            # Support semantic versioning with pre-release and build metadata: v1.0.0-alpha.1+build.1
            if [[ $BRANCH_NAME =~ ^release/v?([0-9]+\.[0-9]+\.[0-9]+)(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$ ]]; then
              VERSION_NUMBER="${BASH_REMATCH[1]}"
              PRERELEASE_PART="${BASH_REMATCH[2]}"
              BUILD_PART="${BASH_REMATCH[3]}"
              
              # Construct full version with build metadata if present
              VERSION="v${VERSION_NUMBER}${PRERELEASE_PART}${BUILD_PART}"
              
              # Check if it's a prerelease based on version suffix (has dash followed by letter)
              if [[ $VERSION =~ -[a-zA-Z] ]]; then
                PRERELEASE=true
              else
                PRERELEASE=false
              fi
            else
              echo "Invalid release branch format: $BRANCH_NAME"
              echo "Expected format: release/v1.0.0, release/1.0.0, release/v1.0.0-alpha.1, or release/v1.0.0+build.1"
              exit 1
            fi
          elif [[ "${{ github.event_name }}" == "create" ]]; then
            # Branch creation event - extract version but don't create release yet
            BRANCH_NAME="${{ github.ref_name }}"
            echo "New release branch created: $BRANCH_NAME"
            echo "Waiting for commits to be pushed to this branch before creating draft release"
            exit 0
          else
            # Fallback - generate next version
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"
            
            # Extract version parts
            if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)(-.*)?$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"
              SUFFIX="${BASH_REMATCH[4]}"
            else
              MAJOR=0
              MINOR=1
              PATCH=0
              SUFFIX=""
            fi
            
            # Determine increment type based on commit messages since last tag
            if git log --pretty=format:"%s" ${LATEST_TAG}..HEAD | grep -E "^(feat!|fix!|BREAKING CHANGE)" > /dev/null; then
              # Breaking changes - increment major
              VERSION="v$((MAJOR + 1)).0.0"
            elif git log --pretty=format:"%s" ${LATEST_TAG}..HEAD | grep -E "^feat" > /dev/null; then
              # New features - increment minor
              VERSION="v${MAJOR}.$((MINOR + 1)).0"
            else
              # Bug fixes/patches - increment patch
              VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
            fi
            
            # Check if there are any unreleased changes
            if [[ $(git rev-list ${LATEST_TAG}..HEAD --count) -eq 0 ]]; then
              echo "No changes since last release ${LATEST_TAG}"
              exit 0
            fi
            
            PRERELEASE=false
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "TAG=$VERSION" >> $GITHUB_OUTPUT
          echo "PRERELEASE=$PRERELEASE" >> $GITHUB_OUTPUT
          
          echo "Determined version: $VERSION"
          echo "Pre-release: $PRERELEASE"

      - name: Process CHANGELOG
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TODAY=$(date +%Y-%m-%d)
          
          # Create backup of CHANGELOG
          cp CHANGELOG.md CHANGELOG.md.backup
          
          # Create temporary changelog for this release
          cat > release_changelog.md << CHANGELOG_EOF
          # Release Notes for $VERSION
          
          Released on $TODAY
          
          CHANGELOG_EOF
          
          # Extract unreleased section from CHANGELOG
          if grep -q "## \[Unreleased\]" CHANGELOG.md; then
            # Get content between [Unreleased] and next version using awk for better compatibility
            awk '/## \[Unreleased\]/{flag=1; next} /^## \[/{flag=0} flag' CHANGELOG.md >> release_changelog.md
          fi
          
          # Add git log since last tag if CHANGELOG is empty or minimal
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [[ -n "$LATEST_TAG" ]]; then
            echo "" >> release_changelog.md
            echo "## Changes since $LATEST_TAG" >> release_changelog.md
            echo "" >> release_changelog.md
            
            # Categorize commits
            echo "### Features" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" ${LATEST_TAG}..HEAD --grep="^feat" >> release_changelog.md || echo "- No new features" >> release_changelog.md
            echo "" >> release_changelog.md
            
            echo "### Bug Fixes" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" ${LATEST_TAG}..HEAD --grep="^fix" >> release_changelog.md || echo "- No bug fixes" >> release_changelog.md
            echo "" >> release_changelog.md
            
            echo "### Other Changes" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" ${LATEST_TAG}..HEAD --invert-grep --grep="^feat" --grep="^fix" >> release_changelog.md || echo "- No other changes" >> release_changelog.md
          else
            echo "" >> release_changelog.md
            echo "## All Changes" >> release_changelog.md
            echo "" >> release_changelog.md
            git log --pretty=format:"- %s (%h)" >> release_changelog.md
          fi
          
          # Update main CHANGELOG.md with new version (suppress all output)
          if grep -q "## \[Unreleased\]" CHANGELOG.md; then
            # Use the manage-changelog.sh script but silence all output
            if [[ -f "scripts/manage-changelog.sh" ]]; then
              ./scripts/manage-changelog.sh release "${VERSION#v}" >/dev/null 2>&1 || true
            fi
          fi
          
          # Ensure release changelog file exists for later steps
          if [[ ! -f "release_changelog.md" ]]; then
            echo "Creating fallback changelog as release_changelog.md was not found" >&2
            echo "# Release Notes for $VERSION" > release_changelog.md
            echo "" >> release_changelog.md
            echo "Released on $TODAY" >> release_changelog.md
          fi
          
          echo "Release changelog prepared: release_changelog.md"

      - name: Validate version doesn't exist
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if git tag -l | grep -q "^${VERSION}$"; then
            echo "Tag $VERSION already exists!"
            exit 1
          fi
          
          # Check if draft release already exists
          if gh release view "$VERSION" --json isDraft --jq '.isDraft' 2>/dev/null | grep -q "true"; then
            echo "Draft release $VERSION already exists"
            gh release view "$VERSION"
            exit 1
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build release artifacts
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          
          # Build binary
          make build
          
          # Create release bundle
          mkdir -p release
          cp bin/manager release/karo
          cp -r config release/
          cp -r examples release/
          cp -r scripts release/
          cp -r charts release/
          cp README.md LICENSE CHANGELOG.md release/
          
          # Create tarball by explicitly listing contents to avoid race conditions
          cd release
          tar -czf ../karo-${VERSION#v}.tar.gz \
            karo \
            config/ \
            examples/ \
            scripts/ \
            charts/ \
            README.md \
            LICENSE \
            CHANGELOG.md
          cd ..
          
          # Move tarball to release directory and create checksums
          mv karo-${VERSION#v}.tar.gz release/
          cd release
          sha256sum *.tar.gz > checksums.txt
          cd ..

      - name: Commit CHANGELOG updates
        if: github.event_name == 'push' && startsWith(github.ref_name, 'release/')
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASE_BRANCH="${{ github.ref_name }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are CHANGELOG updates to commit
          if [[ -n "$(git status --porcelain CHANGELOG.md)" ]]; then
            echo "CHANGELOG updates detected, committing to main branch first..."
            
            # Stash any other changes (keep only CHANGELOG.md)
            git add CHANGELOG.md
            git stash push -u -m "Temporary stash for changelog updates"
            
            # Switch to main branch and pull latest
            git fetch origin main
            git checkout main
            git pull origin main
            
            # Apply the CHANGELOG changes to main
            git stash pop
            git add CHANGELOG.md
            
            # Create and commit changes to main
            git commit -m "docs: update CHANGELOG for ${VERSION}
            
            - Prepare release notes for ${VERSION}
            - Move unreleased changes to version section
            - Add placeholder for next unreleased changes
            
            [skip ci]"
            
            # Push to main branch
            git push --force origin main
            
            # Get the commit hash for cherry-picking
            CHANGELOG_COMMIT=$(git rev-parse HEAD)
            echo "CHANGELOG commit on main: $CHANGELOG_COMMIT"
            
            # Switch back to release branch
            git checkout "$RELEASE_BRANCH"
            
            # Cherry-pick the changelog commit to release branch
            echo "Cherry-picking changelog commit to release branch..."
            if git cherry-pick "$CHANGELOG_COMMIT"; then
              echo "Successfully cherry-picked changelog commit to $RELEASE_BRANCH"
              git push --force origin "$RELEASE_BRANCH"
            else
              echo "Cherry-pick failed, attempting manual merge..."
              
              # If cherry-pick fails, try to merge manually
              git checkout main -- CHANGELOG.md
              git add CHANGELOG.md
              git commit -m "docs: update CHANGELOG for ${VERSION} (manual merge)
              
              - Prepare release notes for ${VERSION}
              - Move unreleased changes to version section
              - Add placeholder for next unreleased changes
              
              [skip ci]"
              git push --force origin "$RELEASE_BRANCH"
              
              echo "Manually applied changelog updates to $RELEASE_BRANCH"
            fi
            
            echo "CHANGELOG updates committed to both main and $RELEASE_BRANCH"
          else
            echo "No CHANGELOG updates detected"
          fi

      - name: Create draft release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PRERELEASE="${{ steps.version.outputs.prerelease }}"
          
          # Create draft release
          PRERELEASE_FLAG=""
          if [[ "$PRERELEASE" == "true" ]]; then
            PRERELEASE_FLAG="--prerelease"
          fi
          
          gh release create "$VERSION" \
            --draft \
            $PRERELEASE_FLAG \
            --title "Release $VERSION" \
            --notes-file release_changelog.md \
            release/*.tar.gz \
            release/checksums.txt
          
          echo "Created draft release: $VERSION"
          echo "Review and publish at: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          RELEASE_BRANCH="${{ github.ref_name }}"
          echo "## 📋 Draft Release Created!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🏷️ Version: $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "### 🔗 [Review Draft Release](https://github.com/${{ github.repository }}/releases/tag/$VERSION)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📝 Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the draft release notes and artifacts" >> $GITHUB_STEP_SUMMARY
          echo "2. Test the release artifacts if needed" >> $GITHUB_STEP_SUMMARY
          echo "3. **Publish the release** to trigger Helm chart automation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📋 CHANGELOG Updates:" >> $GITHUB_STEP_SUMMARY
          echo "- CHANGELOG has been updated and committed to **main** branch" >> $GITHUB_STEP_SUMMARY
          echo "- Changes have been cherry-picked to **$RELEASE_BRANCH** branch" >> $GITHUB_STEP_SUMMARY
          echo "- Draft release created from the updated release branch with changelog" >> $GITHUB_STEP_SUMMARY
          echo "- Both branches now contain the updated release notes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ⚠️ Important:" >> $GITHUB_STEP_SUMMARY
          echo "- The Helm chart will only be released when you **publish** the draft release" >> $GITHUB_STEP_SUMMARY
          echo "- Publishing will trigger the full release pipeline including chart packaging" >> $GITHUB_STEP_SUMMARY