#!/bin/bash

# Pre-push Git hook for Karo (Kubernetes Alert Reaction Operator)
# This hook runs comprehensive checks before allowing pushes to remote repositories

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}ðŸš€ Running pre-push checks...${NC}"

# Get information about the push
protected_branch="main"
current_branch=$(git rev-parse --abbrev-ref HEAD)

echo -e "${BLUE}ðŸ“ Current branch: $current_branch${NC}"

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to run a command and handle errors
run_check() {
    local cmd="$1"
    local description="$2"
    
    echo -e "${GREEN}ðŸ”„ $description...${NC}"
    
    if eval "$cmd"; then
        echo -e "${GREEN}âœ… $description passed${NC}"
        return 0
    else
        echo -e "${RED}âŒ $description failed${NC}"
        return 1
    fi
}

# Check for required tools
echo -e "${GREEN}ðŸ”§ Checking for required tools...${NC}"

required_tools=("go" "gofmt")
for tool in "${required_tools[@]}"; do
    if ! command_exists "$tool"; then
        echo -e "${RED}âŒ Required tool '$tool' is not installed${NC}"
        exit 1
    fi
done

# Check for optional tools
if command_exists "golangci-lint"; then
    HAS_GOLANGCI_LINT=true
    echo -e "${GREEN}âœ… golangci-lint found${NC}"
else
    HAS_GOLANGCI_LINT=false
    echo -e "${YELLOW}âš ï¸  golangci-lint not found, skipping advanced linting${NC}"
fi

echo

# 1. Comprehensive formatting check
echo -e "${GREEN}ðŸŽ¨ Checking Go formatting across entire codebase...${NC}"
unformatted_files=$(find . -name "*.go" -not -path "./vendor/*" -not -path "./.git/*" -exec gofmt -l {} \;)
if [ -n "$unformatted_files" ]; then
    echo -e "${RED}âŒ The following files are not properly formatted:${NC}"
    echo "$unformatted_files"
    echo -e "${YELLOW}ðŸ’¡ Run 'gofmt -w .' or 'make fmt' to fix formatting${NC}"
    exit 1
else
    echo -e "${GREEN}âœ… All Go files are properly formatted${NC}"
fi

# 2. Run go vet
if ! run_check "go vet ./..." "Go vet analysis"; then
    echo -e "${YELLOW}ðŸ’¡ Run 'make vet' to see detailed issues${NC}"
    exit 1
fi

# 3. Run comprehensive linting with golangci-lint
if [ "$HAS_GOLANGCI_LINT" = true ]; then
    if ! run_check "golangci-lint run --timeout=10m" "Comprehensive linting with golangci-lint"; then
        echo -e "${YELLOW}ðŸ’¡ Run 'golangci-lint run' to see detailed issues${NC}"
        exit 1
    fi
else
    echo -e "${YELLOW}âš ï¸  Skipping golangci-lint (not installed)${NC}"
    echo -e "${YELLOW}ðŸ’¡ Install golangci-lint for better code quality: https://golangci-lint.run/usage/install/${NC}"
fi

# 4. Verify go.mod and go.sum are clean
echo -e "${GREEN}ðŸ“¦ Verifying Go modules are clean...${NC}"
cp go.mod go.mod.backup
cp go.sum go.sum.backup

go mod tidy

if ! cmp -s go.mod go.mod.backup || ! cmp -s go.sum go.sum.backup; then
    echo -e "${RED}âŒ go.mod or go.sum are not up to date${NC}"
    echo -e "${YELLOW}ðŸ’¡ Run 'go mod tidy' and commit the changes${NC}"
    mv go.mod.backup go.mod
    mv go.sum.backup go.sum
    exit 1
else
    echo -e "${GREEN}âœ… Go modules are clean${NC}"
    rm go.mod.backup go.sum.backup
fi

# 5. Build check
if ! run_check "go build ./..." "Go build"; then
    echo -e "${YELLOW}ðŸ’¡ Fix build errors before pushing${NC}"
    exit 1
fi

# 6. Run full test suite
echo -e "${GREEN}ðŸ§ª Running full test suite...${NC}"
if ! run_check "go test ./... -race -timeout=10m" "Full test suite with race detection"; then
    echo -e "${RED}âŒ Tests failed! Cannot push with failing tests.${NC}"
    echo -e "${YELLOW}ðŸ’¡ Run 'make test' to see detailed test failures${NC}"
    exit 1
fi

# 7. Generate code and verify manifests (for Kubernetes operators)
if [ -f "Makefile" ] && grep -q "generate\|manifests" Makefile; then
    echo -e "${GREEN}ï¿½ Generating code and Kubernetes manifests...${NC}"
    
    # Create backup of current generated files and manifests
    generated_backup_dir="/tmp/k8s-operator-backup-$$"
    mkdir -p "$generated_backup_dir"
    
    # Backup zz_generated files
    find . -name "zz_generated.*.go" -not -path "./vendor/*" -not -path "./.git/*" | while read -r file; do
        backup_path="$generated_backup_dir${file}"
        mkdir -p "$(dirname "$backup_path")"
        cp "$file" "$backup_path" 2>/dev/null || true
    done
    
    # Backup manifests
    if [ -d "config/crd" ]; then
        cp -r config/crd "$generated_backup_dir/crd"
    fi
    if [ -d "config/rbac" ]; then
        cp -r config/rbac "$generated_backup_dir/rbac"
    fi
    
    # Generate code first (required for manifests)
    if grep -q "generate" Makefile; then
        if ! run_check "make generate" "Generating controller code"; then
            echo -e "${RED}âŒ Failed to generate code${NC}"
            # Restore backups would be complex here, better to fail fast
            rm -rf "$generated_backup_dir"
            exit 1
        fi
    fi
    
    # Generate manifests
    if grep -q "manifests" Makefile; then
        if ! run_check "make manifests" "Generating Kubernetes manifests"; then
            echo -e "${RED}âŒ Failed to generate manifests${NC}"
            rm -rf "$generated_backup_dir"
            exit 1
        fi
    fi
    
    # Check if generated files changed
    generated_changed=false
    
    # Check zz_generated files
    find . -name "zz_generated.*.go" -not -path "./vendor/*" -not -path "./.git/*" | while read -r file; do
        backup_file="$generated_backup_dir${file}"
        if [ -f "$backup_file" ] && ! cmp -s "$file" "$backup_file"; then
            echo -e "${RED}âŒ Generated file $file is out of date${NC}"
            generated_changed=true
        fi
    done
    
    # Check manifests
    if [ -d "$generated_backup_dir/crd" ] && [ -d "config/crd" ]; then
        if ! diff -r config/crd "$generated_backup_dir/crd" >/dev/null 2>&1; then
            echo -e "${RED}âŒ CRD manifests are out of date${NC}"
            generated_changed=true
        fi
    fi
    
    if [ -d "$generated_backup_dir/rbac" ] && [ -d "config/rbac" ]; then
        if ! diff -r config/rbac "$generated_backup_dir/rbac" >/dev/null 2>&1; then
            echo -e "${RED}âŒ RBAC manifests are out of date${NC}"
            generated_changed=true
        fi
    fi
    
    # Clean up backup directory
    rm -rf "$generated_backup_dir"
    
    if [ "$generated_changed" = true ]; then
        echo -e "${YELLOW}ðŸ’¡ Run 'make generate && make manifests' and commit the changes${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}âœ… Generated code and Kubernetes manifests are up to date${NC}"
fi

# 8. Check for sensitive information (basic check)
echo -e "${GREEN}ðŸ”’ Checking for potential sensitive information...${NC}"
sensitive_patterns=("password" "secret" "token" "key.*=" "api.*key")
found_sensitive=false

for pattern in "${sensitive_patterns[@]}"; do
    if git diff --cached --name-only | xargs grep -i "$pattern" 2>/dev/null | grep -v "test" | grep -v ".md" | grep -v ".sample"; then
        found_sensitive=true
    fi
done

if [ "$found_sensitive" = true ]; then
    echo -e "${YELLOW}âš ï¸  Potential sensitive information detected in staged files${NC}"
    echo -e "${YELLOW}ðŸ’¡ Please review the above matches and ensure no secrets are being committed${NC}"
    echo -e "${YELLOW}Press ENTER to continue or Ctrl+C to abort...${NC}"
    read -r
fi

# 9. Additional checks for main/master branch
if [ "$current_branch" = "$protected_branch" ] || [ "$current_branch" = "master" ]; then
    echo -e "${YELLOW}âš ï¸  Pushing to protected branch: $current_branch${NC}"
    echo -e "${YELLOW}ðŸ’¡ Ensure this push has been reviewed and approved${NC}"
    
    # Check if we're ahead of origin
    if git rev-list --count '@{u}'.. >/dev/null 2>&1; then
        commits_ahead=$(git rev-list --count '@{u}'..)
        echo -e "${BLUE}ðŸ“Š You are $commits_ahead commit(s) ahead of origin/$current_branch${NC}"
    fi
fi

echo
echo -e "${GREEN}ðŸŽ‰ All pre-push checks passed! ðŸš€${NC}"
echo -e "${BLUE}ðŸ“¤ Proceeding with push to remote repository...${NC}"